---
title: "Capstone Project"
author: "Clara Pineda"
date: "2025-02-03"
output:
  html_document: default
  pdf_document: default
---

SUMMARY: This research project compares the age-specific Healthcare Access and Quality (HAQ) indices among US States for 2010 and 2016. The HAQ index is based on amenable mortality (a measure of deaths that could have been prevented with timely and effective healthcare).

RESEARCH QUESTION: Does the Healthcare Access and Quality index vary across ages among US states (are they comparable or incompatible)? Additionally, is there any observed association between private or public insurance coverage and higher indices?

GOAL: Compare US States with varying insurance coverage (a combination of private and public coverage).

```{r}
#Load libraries
library(tidyverse)
library(dplyr)
library(ggplot2)
library(car)
library(MASS)
library(olsrr)
library(leaps)
library(lmtest)
library(stats)
library(sandwich)
library(plotly)

#Import dataset
#---Results are available for 50 states + District of Columbia. 
#---Each state has 2 observations (corresponding to the years 2010 and 2016) for each age group.
#---There are 16 age groups, which encompass ages from 0-11 months (group 1) to 70-74 years (group 16). Each group, except for group 1, contains 4 individual age numbers (1-4,5-9,etc.)

setwd("/Users/clarapineda/Desktop/CAPSTONE - STATS/CAPSTONE - STATS")
healthcare.data <- read.csv("IHME_HAQ_INDEX_1990_2016_US_STATES_Y2021M11D17.CSV", header = TRUE, sep = ",")

#Now, the imported dataset will be arranged by year in order to account for differences over this 6-year period.
clean_healthcare_data <- healthcare.data %>% arrange(year_id)

#Now, we will create categories for all age groups and using this categories to create a new variable: AGE1.
#--- Final categories: Children, Adolescents, Young Adults, Adults, Seniors.
categories <- c("Children","Adolescents", "Young Adults","Adults","Seniors")
clean_healthcare_data <- clean_healthcare_data %>% mutate(age1 = case_when( age_group_id >= 4 & age_group_id<= 6 ~categories[1], age_group_id >= 7 & age_group_id <= 9 ~categories[2], age_group_id >= 10 & age_group_id <= 12 ~ categories[3], age_group_id >= 13 & age_group_id <= 16 ~categories[4], age_group_id >= 17 & age_group_id <=19 ~ categories[5]))
```

The next sections will explore different multivariate regression models for 1 State, 5 states, and 51 states, respectively, considering the following variable assignment:

- Response: Health Access and Quality (HAQ) index
- Predictors: median income, Private insurance, Public insurance, Total insurance, and the interaction term of a newly created variable (age1) with the aforementioned predictors.

In addition, we have found that the final model that best describes the data is the following:

$Y_i= Œ≤_0+Œ≤_1X_{1i}+Œ≤_2X_{2i}+Œ≤_3X_{3i}+Œ£_{a=2}^{5}[Œ≤_{0a}d_{ai}+ùõæ_{1a}d_{ai}X_{1i}+ùõæ_{2a}d_{ai}X_{2i}+ùõæ_{3a}d_{ai}X_{3i}]+Œµ_i$

where $i=1,...,n$, $a=2,...,5$, $x_i,x_2,x_3$ represent income, public, and private, and $Œµ_i$ follows N ~ $(0,ùúé^2)$

-> The category "Adolescents" has been chosen as the reference age category, so we create dummy variables for the remaining categories: $d_{1i}=1$ if age1$_i$ = Children, 0 otherwise. Similarly, $d_{3i},d_{4i},d_{5i}$ for Young Adults, Adults, and Seniors, respectively.


-> The intercept $Œ≤_{0a}$ is is the expected difference in HAQ index between each age group $a$ and Adolescents when all continuous predictors are at their reference value (i.e., median-income is at its center, and the private and public coverage rates are at their centers).


-> The extra‚Äëslope $ùõæ_{ia}$ simply explains ‚Äúhow much steeper or flatter this age group‚Äôs line is compared with Adolescents‚Äù.


Interpretation of the model: Start with a baseline line (intercept) and four baseline slopes $Œ≤_{1-4}$. Then, let every age group have its own intercept shift and its own extra slope for each continuous predictor (income, private, public).

*1 state*

```{r}
#Initial model - Indiana
indiana_2010 <- clean_healthcare_data %>% filter(location_name == "Indiana", year_id == 2010)
indiana_2016 <- clean_healthcare_data %>% filter(location_name == "Indiana", year_id == 2016)

first_model_2010 <- lm(index ~ age1*(median_income + Total + Private + Public), data = indiana_2010)

first_model_2016 <- lm(index~ age1*(median_income + Total + Private + Public), data = indiana_2016)

#Plotting the models (by year, the same state)
ggplot(indiana_2010, aes(x = age_group_id, y = index, color = location_name, group = location_name)) + geom_line() + geom_point() + labs(title = "Index by Age Group (2010) for Indiana", x = "Age Group", y = "Index")

ggplot(indiana_2016, aes(x = age_group_id, y = index, color = location_name, group = location_name)) + geom_line() + geom_point() + labs(title = "Index by Age Group (2016) for Indiana", x = "Age Group", y = "Index")
```

*Diagnostics for the initial model*

```{r}
#---------------------- NOTES ON DIAGNOSTICS -------------------------: 
#-- The first model (for both years) contains too few observations and is therefore not significant to the overarching goal, however, we wanted to make the interpretation of HAQ indices easy to digest by displaying the distribution for a single state.
#-- We do not perform the Shapiro Test for normality for this first model because there are too few observations and is therefore not significant to the overarching goal.
#-- We do not perform the Breusch-Pagan test for Heteroscedasticity for the same reason as above.
# -- We do not perform the Backward Selection Procedure because we have more parameters than observations and this would not yield a comprehensive result.

#checking the normality condition in the residuals
par(mfrow = c(1, 2)) 
qqnorm(residuals(first_model_2010)) #QQ-Plot
qqnorm(residuals(first_model_2016))
plot(first_model_2010, which = 1) # Residuals vs. Fitted
plot(first_model_2016, which = 1) 
```


*5 states*


```{r}
#Choosing 5 states for the second model
selected_states <- c("Indiana", "Texas", "New York", "Mississippi", "Idaho") #From every major region in the U.S.
severalStates_2010 <- clean_healthcare_data %>% dplyr::filter(location_name %in% selected_states, year_id == 2010)
severalStates_2016 <- clean_healthcare_data %>% dplyr::filter(location_name %in% selected_states, year_id == 2016)

#Second model:2010
#1
second_model_2010 <- lm(index ~ age1*(median_income + Total  + Private + Public), data = severalStates_2010) #Since this model previously showed heteroscedasticity, we had to re-model by adding the weighted least squares (w)
abs_resid <- abs(residuals(second_model_2010))
var_model <- lm(abs_resid ~ median_income + Total + Private + Public, data = severalStates_2010) #these are the predictors we think were causing the heteroscedasticity
fitted_var <- fitted(var_model) #Construct weights  w_i = 1 / (fitted variance)^2
w <- 1 / (fitted_var^2)
#2: with weighted-least-squares to remove the heteroscedasticity
second_model_2010_wls <- lm(index ~ age1*(median_income + Total  + Private + Public), data = severalStates_2010, weights = w)

#Second model:2016
#1
second_model_2016 <- lm(index ~ age1*(median_income + Total + Private + Public), data = severalStates_2016)
abs_resid2 <- abs(residuals(second_model_2016))
var_model2 <- lm(abs_resid2 ~ median_income + Total + Private + Public, data = severalStates_2016)
fitted_var2 <- fitted(var_model2)
w2 <- 1 / (fitted_var2^2)
#2: with weighted-least-squares to remove the heteroscedasticity
second_model_2016_wls <- lm(index ~ age1*(median_income + Total  + Private + Public), data = severalStates_2016, weights = w2)

#Plotting the models (by year, the same group of states)
ggplot(severalStates_2010, aes(x = age_group_id, y = index, color = location_name, group = location_name)) + geom_line() + geom_point() + labs(title = "Index by Age Group (2010) for Various States", x = "Age Group", y = "Index")

ggplot(severalStates_2016, aes(x = age_group_id, y = index, color = location_name, group = location_name)) + geom_line() + geom_point() + labs(title = "Index by Age Group (2016) for Various States", x = "Age Group", y = "Index")
```


*Diagnostics for the initial second model (with BACKWARD SELECTION PROCEDURE and ANOVA)*


```{r}
#Shapiro test for normality
shapiro.test(residuals(second_model_2010_wls)) #Since the p-value is greater than 0.05, we accept (fail to reject) the null hypothesis that the data follows a normal distribution (normality condition passed)
shapiro.test(residuals(second_model_2016_wls)) #Normality condition passed as well

#checking the normality condition in the residuals
par(mfrow = c(1, 2)) 
qqnorm(residuals(second_model_2010_wls)); qqline(residuals(second_model_2010_wls), col = "red")
qqnorm(residuals(second_model_2016_wls)); qqline(residuals(second_model_2016_wls), col = "red")
boxplot(residuals(second_model_2010_wls))
boxplot(residuals(second_model_2016_wls))
boxcox(second_model_2010_wls,lambda = seq(-5,2)) #The result indicates a log transformation is NOT necessary since it contains 1
boxcox(second_model_2016_wls,lambda = seq(-5,2)) #Same as above
cook <- cooks.distance(second_model_2010_wls)
cook1 <- cooks.distance(second_model_2016_wls)

#Breusch-Pagan test to detect heteroscedasticity.
bptest(second_model_2010_wls, studentize = TRUE) 
bptest(second_model_2016_wls, studentize = TRUE)

#Residuals vs. Fitted
plot(second_model_2010_wls, which = 1)
plot(second_model_2016_wls, which = 1) 

#VIF
vif(second_model_2010_wls, type = 'predictor') #what does this mean?
vif(second_model_2016_wls, type = 'predictor') #what does this mean?

#Selection procedure
#---- Several States year 2010
backward_selection <- step(second_model_2010_wls, direction = "backward", trace = FALSE) #We run this procedure to obtain a parsimonious, hierarchy-respecting model 
summary(backward_selection)
Anova(second_model_2010_wls, type = 3)
#---- Several States year 2016
backward_selection <- step(second_model_2016_wls, direction = "backward", trace = FALSE)
summary(backward_selection)
Anova(second_model_2016_wls, type = 3)
```


*Final model for the 5 states*


```{r}
#HAQ 2010
#-----Final model according to the backward selection procedure, VIF, and ANOVA-----
final_second_model_2010 <- lm(index ~ age1 + Total + Public + age1:Total + age1:Public, data = severalStates_2010, weights = w)
summary(final_second_model_2010) #Here, the main effect is drawn from "Total", and since this represents the total insurance coverage by age group, it means that age groups with higher HAQ indices had a greater insurance coverage
#HAQ 2016
#-----Final model according to the backward selection procedure, VIF, and ANOVA-----
final_second_model_2016 <- lm(index ~ age1 + median_income + Public + age1:Public, data = severalStates_2016, weights = w2)
summary(final_second_model_2016)
```


*Diagnostics for the FINAL second model*


```{r}
#Shapiro test for normality
shapiro.test(residuals(final_second_model_2010)) #Since the p-value is greater than 0.05, we accept (fail to reject) the null hypothesis that the data follows a normal distribution (normality condition passed)
shapiro.test(residuals(final_second_model_2016)) #Normality condition passed as well

#checking the normality condition in the residuals
par(mfrow = c(1, 2)) 
qqnorm(residuals(final_second_model_2010)); qqline(residuals(final_second_model_2010), col = "red")
qqnorm(residuals(final_second_model_2016)); qqline(residuals(final_second_model_2016), col = "red")
boxplot(residuals(final_second_model_2010))
boxplot(residuals(final_second_model_2016))
boxcox(final_second_model_2010,lambda = seq(-5,2)) #The result indicates a log transformation is NOT necessary since it contains 1
boxcox(final_second_model_2016,lambda = seq(-5,2)) #Same as above
cook <- cooks.distance(final_second_model_2010)
cook1 <- cooks.distance(final_second_model_2016)

#Breusch-Pagan test to detect heteroscedasticity.
bptest(final_second_model_2010, studentize = TRUE) 
bptest(final_second_model_2016, studentize = TRUE)

#Residuals vs. Fitted
plot(final_second_model_2010, which = 1)
plot(final_second_model_2016, which = 1) 

#VIF
vif(final_second_model_2010, type = 'predictor') #what does this mean?
vif(final_second_model_2016, type = 'predictor') #what does this mean?
```


*All 50+DC states*


```{r}
healthcare_data_2010 <- clean_healthcare_data %>% filter(year_id == 2010)
healthcare_data_2016 <- clean_healthcare_data %>% filter(year_id == 2016)

#Third model: 2010
#1
third_model_2010 <- lm(index ~ age1*(median_income + Total + Private + Public), data = healthcare_data_2010)
abs_resid3 <- abs(residuals(third_model_2010))
var_model3 <- lm(abs_resid3 ~ median_income + Total + Private + Public, data = healthcare_data_2010)
fitted_var3 <- fitted(var_model3)
w3 <- 1 / (fitted_var3^2)
#2
third_model_2010_wls <- lm(index ~ age1*(median_income + Total + Private + Public), data = healthcare_data_2010, weights = w3)

#Third model: 2016
#1
third_model_2016 <- lm(index ~ age1*(median_income + Total + Private + Public), data = healthcare_data_2016)
abs_resid4 <- abs(residuals(third_model_2016))
var_model4 <- lm(abs_resid4 ~ median_income + Total + Private + Public, data = healthcare_data_2016)
fitted_var4 <- fitted(var_model4)
w4 <- 1 / (fitted_var4^2)
#2
third_model_2016_wls <- lm(index ~ age1*(median_income + Total + Private + Public), data = healthcare_data_2016, weights = w4)

#Plotting the models (by year, all states)
p <- ggplot(healthcare_data_2010, aes(x = age_group_id, y = index, color = location_name, group = location_name)) + geom_line() + geom_point() + labs(title = "Index by Age Group (2010) All",x = "Age Group", y = "Index")

q <- ggplot(healthcare_data_2016, aes(x = age_group_id, y = index, color = location_name, group = location_name)) + geom_line() + geom_point() + labs(title = "Index by Age Group (2016) All", x = "Age Group", y = "Index")

ggplotly(p)
ggplotly(q)
```


*Diagnostics for the initial third model (with BACKWARD SELECTION PROCEDURE and ANOVA)*


```{r}
#Shapiro test for normality
shapiro.test(residuals(third_model_2010_wls))
shapiro.test(residuals(third_model_2016_wls))

#checking the normality condition in the residuals
par(mfrow = c(1, 2)) 
qqnorm(residuals(third_model_2010_wls)); qqline(residuals(third_model_2010_wls), col = "red")
qqnorm(residuals(third_model_2016_wls)); qqline(residuals(third_model_2016_wls), col = "red")
boxplot(residuals(third_model_2010_wls))
boxplot(residuals(third_model_2016_wls))
boxcox(third_model_2010_wls,lambda = seq(-5,2)) #The result indicates a log transformation is NOT necessary since it contains 1
boxcox(third_model_2016_wls,lambda = seq(-5,2)) #Same as above
cook2 <- cooks.distance(third_model_2010_wls)
cook3 <- cooks.distance(third_model_2016_wls)

#Breusch-Pagan test to detect heteroscedasticity.
bptest(third_model_2010_wls, studentize = TRUE) 
bptest(third_model_2016_wls, studentize = TRUE)

#Residuals vs. Fitted
plot(third_model_2010_wls, which = 1)
plot(third_model_2016_wls, which = 1) 

#VIF
vif(third_model_2010_wls, type = "predictor")
vif(third_model_2016_wls, type = "predictor")

#Selection procedure
#---- All States year 2010
backward_selection <- step(third_model_2010_wls, direction = "backward", trace = FALSE) #We run this procedure to obtain a parsimonious, hierarchy-respecting model 
summary(backward_selection)
Anova(third_model_2010_wls, type = 3)
#---- All States year 2016
backward_selection <- step(third_model_2016_wls, direction = "backward", trace = FALSE)
summary(backward_selection)
Anova(third_model_2016_wls, type = 3)
```


*Final model for the All States*


```{r}
#HAQ 2010
#-----Final model according to the backward selection procedure, VIF, and ANOVA-----
final_third_model_2010 <- lm(index ~ age1*(median_income + Private + Public), data = healthcare_data_2010, weights = w3) #We had to drop Total because of the high multicollinearity with Private and Public
summary(final_third_model_2010)
#HAQ 2016
#-----Final model according to the backward selection procedure, VIF, and ANOVA-----
final_third_model_2016 <- lm(index ~ age1*(median_income + Private + Public), data = healthcare_data_2016, weights = w4) #We had to drop Total because of the high multicollinearity with Private and Public
summary(final_third_model_2016)
```


*Diagnostics for the FINAL third model*


```{r}
#Shapiro test for normality
shapiro.test(residuals(final_third_model_2010))
shapiro.test(residuals(final_third_model_2016))

#checking the normality condition in the residuals
par(mfrow = c(1, 2)) 
qqnorm(residuals(final_third_model_2010)); qqline(residuals(final_third_model_2010), col = "red")
qqnorm(residuals(final_third_model_2016)); qqline(residuals(final_third_model_2016), col = "red")
boxplot(residuals(final_third_model_2010))
boxplot(residuals(final_third_model_2016))
boxcox(final_third_model_2010,lambda = seq(-5,2)) #The result indicates a log transformation is NOT necessary since it contains 1
boxcox(final_third_model_2016,lambda = seq(-5,2)) #Same as above
cook2 <- cooks.distance(final_third_model_2010)
cook3 <- cooks.distance(final_third_model_2016)

#Breusch-Pagan test to detect heteroscedasticity.
bptest(final_third_model_2010, studentize = TRUE) 
bptest(final_third_model_2016, studentize = TRUE)

#Residuals vs. Fitted
plot(final_third_model_2010, which = 1)
plot(final_third_model_2016, which = 1) 

#VIF
vif(final_third_model_2010, type = "predictor")
vif(final_third_model_2016, type = "predictor")

#AIC
AIC_2010 <- step(final_third_model_2010, direction="both", criterion='AIC'); summary(AIC_2010)
AIC_2016 <- step(final_third_model_2016, direction="both", criterion='AIC'); summary(AIC_2016)
plot(AIC_2010, main = "AIC for HAQ Scores 2010", col="blue")
plot(AIC_2016, main = "AIC for HAQ Scores 2016", col="blue")
```

